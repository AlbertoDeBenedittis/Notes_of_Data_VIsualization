---
title: 'R Basics: quick (and partial) summary'
author: "Giuseppe Jurman"
date: "February, 24th 2021"
output:
  html_notebook:
    number_sections: yes
  pdf_document: default
---


# The R environment and the notebooks XXX
(Partly abridged from [An Introduction to R](https://cran.r-project.org/doc/manuals/r-release/R-intro.html) and from [Tutorial on the R Apply Family](https://www.datacamp.com/community/tutorials/r-tutorial-apply-family) )

R is an integrated suite of software facilities for data manipulation, calculation and graphical display. Among other things it has

* an effective data handling and storage facility,
* a suite of operators for calculations on arrays, in particular matrices,
* a large, coherent, integrated collection of intermediate tools for data analysis,
* graphical facilities for data analysis and display either directly at the computer or on hardcopy, and
* a well developed, simple and effective programming language (called ‘S’) which includes conditionals, loops, user defined recursive functions and input and output facilities. (Indeed most of the system supplied functions are themselves written in the S language.)

The term “environment” is intended to characterize it as a fully planned and coherent system, rather than an incremental accretion of very specific and inflexible tools, as is frequently the case with other data analysis software.

R can be regarded as an implementation of the S language which was developed at Bell Laboratories by Rick Becker, John Chambers and Allan Wilks, and also forms the basis of the S-PLUS systems.

R consists of a core engine, plus additional *packages* available either at a [CRAN](https://cran.r-project.org/mirrors.html) mirror or at the respective developer's site
Packages can be installed either through the RStudio interface or using the R command *install.packages()*.
Also help can be accessed via the RStudio interface, or by the command *?*.

In this course we will use R in the [RStudio](https://www.rstudio.com/) integrated development environment (IDE) as [R notebooks](https://bookdown.org/yihui/rmarkdown/notebook.html) (similar to Jupyter for Python), mixing *markdown* text and R code *chunks* can can be executed inline, producing a final report (*e.g.* in HTML or PDF, or even [slides](https://bookdown.org/yihui/rmarkdown/ioslides-presentation.html)) including text, code and code output.

The text is written in a dialect of the [markdown](https://en.wikipedia.org/wiki/Markdown) language, a lightweight markup language with plain text formatting syntax easily convertible in many output formats. In particular, R adopts the [Pandoc](https://pandoc.org/) version, which is one of the most comprehensive. The [quick guide](https://bookdown.org/yihui/rmarkdown/markdown-syntax.html) to the R markdown syntax can be of help, together with this practical [cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf). As a major non-standard feature, the possibility of including LaTeX syntax inline (*e.g.* $f(k) = {n \choose k} p^{k} (1-p)^{n-k}$). The R code is written inside a code chunk, and the code output immediately follows in the output.

Example:
```{r}
print("Hello World!")
```

R code chunks are fully customizable by setting the [chunk options](https://yihui.name/knitr/options/#code-chunk), which, among others, include the plot features, the text format feature and the possibility of caching the code chunk for later use.

***
# Workspace
The entities that R creates and manipulates are known as objects. These may be variables, arrays of numbers, character strings, functions, or more general structures built from such components.

During an R session, objects are created and stored by name (we discuss this process in the next section). The R commands
```{r, eval=FALSE}
objects()
```
or
```{r, eval=FALSE}
ls()
```
can be used to display the names of (most of) the objects which are currently stored within R. 
The collection of objects currently stored is called the workspace.
In RStudio, the workspace is timely shown under the *Environment* menu.

To remove objects the function rm is available:
```{r, eval=FALSE}
rm(object_name)
```
All objects created during an R session can be stored permanently in a file for use in future R sessions. At the end of each R session you are given the opportunity to save all the currently available objects. If you indicate that you want to do this, the objects are written to a file called .RData6 in the current directory, and the command lines used in the session are saved to a file called .Rhistory.

When R is started at later time from the same directory it reloads the workspace from this file. At the same time the associated commands history is reloaded.

*Caveat:* it is recommended that you should use separate working directories for analyses conducted with R. It is quite common for objects with names x and y to be created during an analysis. Names like this are often meaningful in the context of a single analysis, but it can be quite hard to decide what they might be when the several analyses have been conducted in the same directory.

***
# Objects
## Vectors
R operates on named data structures. The simplest such structure is the numeric vector, which is a single entity consisting of an ordered collection of numbers. To set up a vector named x, say, consisting of five numbers, namely 10.4, 5.6, 3.1, 6.4 and 21.7, use the R command

```{r}
x <- c(10.4, 5.6, 3.1, 6.4, 21.7)
```
This is an assignment statement using the function c() which in this context can take an arbitrary number of vector arguments and whose value is a vector got by concatenating its arguments end to end.7

A number occurring by itself in an expression is taken as a vector of length one.

Notice that the assignment operator (‘<-’), which consists of the two characters ‘<’ (“less than”) and ‘-’ (“minus”) occurring strictly side-by-side and it ‘points’ to the object receiving the value of the expression. In most contexts the ‘=’ operator can be used as an alternative.

Assignment can also be made using the function assign(). An equivalent way of making the same assignment as above is with:
```{r}
assign("x", c(10.4, 5.6, 3.1, 6.4, 21.7))
```
The usual operator, <-, can be thought of as a syntactic short-cut to this.

Assignments can also be made in the other direction, using the obvious change in the assignment operator. So the same assignment could be made using

```{r}
c(10.4, 5.6, 3.1, 6.4, 21.7) -> x
```
If an expression is used as a complete command, the value is printed and **lost**. So now if we were to use the command
```{r}
1/x
```
the reciprocals of the five values would be printed at the terminal (and the value of x, of course, unchanged).

The further assignment
```{r}
y <- c(x, 0, x)
```
would create a vector y with 11 entries consisting of two copies of x with a zero in the middle place.

Vectors can be used in arithmetic expressions, in which case the operations are performed element by element. Vectors occurring in the same expression need not all be of the same length. If they are not, the value of the expression is a vector with the same length as the longest vector which occurs in the expression. Shorter vectors in the expression are recycled as often as need be (perhaps fractionally) until they match the length of the longest vector, issuing a warning. In particular a constant is simply repeated. So with the above assignments the command
```{r}
v <- 2*x + y + 1
```
generates a new vector v of length 11 constructed by adding together, element by element, 2*x repeated 2.2 times, y repeated just once, and 1 repeated 11 times.  

The elementary arithmetic operators are the usual +, -, \*, / and ^ for raising to a power. In addition all of the common arithmetic functions are available. *log, exp, sin, cos, tan, sqrt*, and so on, all have their usual meaning. max and min select the largest and smallest elements of a vector respectively. range is a function whose value is a vector of length two, namely *c(min(x), max(x)). length(x)* is the number of elements in *x*, *sum(x)* gives the total of the elements in *x*, and *prod(x)* their product.

Two statistical functions are mean(x) which calculates the sample mean, which is the same as *sum(x)/length(x)*, and *var(x)* which gives
```{r}
sum((x-mean(x))^2)/(length(x)-1)
```
or sample variance. If the argument to *var()* is an n-by-p matrix the value is a p-by-p sample covariance matrix got by regarding the rows as independent p-variate sample vectors.

*sort(x)* returns a vector of the same size as x with the elements arranged in increasing order; however there are other more flexible sorting facilities available (see *order()* or *sort.list()* which produce a permutation to do the sorting).

Note that *max* and *min* select the largest and smallest values in their arguments, even if they are given several vectors. The parallel maximum and minimum functions *pmax* and *pmin* return a vector (of length equal to their longest argument) that contains in each element the largest (smallest) element in that position in any of the input vectors.

For most purposes the user will not be concerned if the “numbers” in a numeric vector are integers, reals or even complex. Internally calculations are done as double precision real numbers.

In some cases the components of a vector may not be completely known. When an element or value is “not available” or a “missing value” in the statistical sense, a place within a vector may be reserved for it by assigning it the special value NA. In general any operation on an NA becomes an NA. The motivation for this rule is simply that if the specification of an operation is incomplete, the result cannot be known and hence is not available.

The function *is.na(x)* gives a logical vector of the same size as x with value TRUE if and only if the corresponding element in x is NA.

***
## Character vectors
Character quantities and character vectors are used frequently in R, for example as plot labels. Where needed they are denoted by a sequence of characters delimited by the double quote character, *e.g.,* "x-values", "New iteration results".

Character strings are entered using either matching double (") or single (') quotes, but are printed using double quotes (or sometimes without quotes). 

Character vectors may be concatenated into a vector by the *c()* function; examples of their use will emerge frequently.

The *paste()* function takes an arbitrary number of arguments and concatenates them one by one into character strings. Any numbers given among the arguments are coerced into character strings in the evident way, that is, in the same way they would be if they were printed. The arguments are by default separated in the result by a single blank character, but this can be changed by the named argument, sep=string, which changes it to string, possibly empty.

For example
```{r}
labs <- paste(c("X","Y"), 1:10, sep="")
```
makes labs into the character vector
```{r}
c("X1", "Y2", "X3", "Y4", "X5", "Y6", "X7", "Y8", "X9", "Y10")
```
Note particularly that recycling of short lists takes place here too; thus *c("X", "Y")* is repeated 5 times to match the sequence 1:10.

***
## Index vectors & slicing
**Caveat** *In R, indexing starts from 1 (not from 0 as in C/Python)*

Subsets of the elements of a vector may be selected by appending to the name of the vector an index vector in square brackets. More generally any expression that evaluates to a vector may have subsets of its elements similarly selected by appending an index vector in square brackets immediately after the expression.

Such index vectors can be any of four distinct types.

* **A logical vector** In this case the index vector is recycled to the same length as the vector from which elements are to be selected. Values corresponding to TRUE in the index vector are selected and those corresponding to FALSE are omitted. For example
```{r}
x <- c(-1,-2,3,4,NA,NA,7,8,9)
y <- x[!is.na(x)]
print(y)
```
creates (or re-creates) an object y which will contain the non-missing values of x, in the same order. Note that if x has missing values, y will be shorter than x. Also
```{r}
(x+1)[(!is.na(x)) & x>0] -> z
print(z)
```
creates an object z and places in it the values of the vector x+1 for which the corresponding value in x was both non-missing and positive.

* **A vector of positive integral quantities** In this case the values in the index vector must lie in the set {1, 2, …, length(x)}. The corresponding elements of the vector are selected and concatenated, in that order, in the result. The index vector can be of any length and the result is of the same length as the index vector. For example x[6] is the sixth component of x and
```{r}
x[1:10]
```
selects the first 10 elements of x padding by NA. 

* **A vector of negative integral quantities** Such an index vector specifies the values to be excluded rather than included. Thus
```{r}
x[-(1:5)]
```

* **A vector of character strings**. This possibility only applies where an object has a names attribute to identify its components. In this case a sub-vector of the names vector may be used in the same way as the positive integral labels in item 2 further above.
```{r}
fruit <- c(5, 10, 1, 20)
names(fruit) <- c("orange", "banana", "apple", "peach")
lunch <- fruit[c("apple","orange")]
print(lunch)
```
The advantage is that alphanumeric names are often easier to remember than numeric indices. This option is particularly useful in connection with data frames, as we shall see later.

An indexed expression can also appear on the receiving end of an assignment, in which case the assignment operation is performed only on those elements of the vector. The expression must be of the form vector[index_vector] as having an arbitrary expression in place of the vector name does not make much sense here.

For example
```{r}
x[is.na(x)] <- 0
print(x)
```
replaces any missing values in x by zeros and
```{r, eval=FALSE}
y[y < 0] <- -y[y < 0]
```
has the same effect as
```{r, eval=FALSE}
> y <- abs(y)
```

## Factors
A factor is a vector object used to specify a discrete classification (grouping) of the components of other vectors of the same length. R provides both ordered and unordered factors.

Suppose, for example, we have a sample of 30 tax accountants from all the states and territories of Australia and their individual state of origin is specified by a character vector of state mnemonics as
```{r}
state <- c("tas", "sa",  "qld", "nsw", "nsw", "nt",  "wa",  "wa",
             "qld", "vic", "nsw", "vic", "qld", "qld", "sa",  "tas",
             "sa",  "nt",  "wa",  "vic", "qld", "nsw", "nsw", "wa",
             "sa",  "act", "nsw", "vic", "vic", "act")
print(state)
```

A factor is similarly created using the factor() function:

```{r}
statef <- factor(state)
print(statef)
```
The print() function handles factors slightly differently from other objects:

To find out the levels of a factor the function levels() can be used.

```{r}
levels(statef)
```

The levels of factors are stored in alphabetical order, or in the order they were specified to factor if they were specified explicitly.

Sometimes the levels will have a natural ordering that we want to record and want our statistical analysis to make use of. The *ordered()* function creates such ordered factors but is otherwise identical to factor. 

Recall that a factor defines a partition into groups. Similarly a pair of factors defines a two way cross classification, and so on. The function table() allows frequency tables to be calculated from equal length factors. If there are k factor arguments, the result is a k-way array of frequencies.

Suppose, for example, that statef is a factor giving the state code for each entry in a data vector. The assignment
```{r}
statefr <- table(statef)
print(statefr)
```
gives in *statefr* a table of frequencies of each state in the sample. The frequencies are ordered and labelled by the levels attribute of the factor. 

Further suppose that incomef is a factor giving a suitably defined “income class” for each entry in the data vector, for example with the cut() function:
```{r}
incomes <- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56,
               61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46,
               59, 46, 58, 43)
factor(cut(incomes, breaks = 35+10*(0:7))) -> incomef
```
Then to calculate a two-way table of frequencies:
```{r}
table(incomef,statef)
```
Extension to higher-way frequency tables is immediate.

***
## Array
An array can be considered as a multiply subscripted collection of data entries, for example numeric. R allows simple facilities for creating and handling arrays, and in particular the special case of matrices.

A dimension vector is a vector of non-negative integers. If its length is k then the array is k-dimensional, *e.g.*, a matrix is a 2-dimensional array. The dimensions are indexed from one up to the values given in the dimension vector.

A vector can be used by R as an array only if it has a dimension vector as its dim attribute. Suppose, for example, z is a vector of 60 elements. The assignment
```{r}
z <- seq(1,60)
dim(z) <- c(3,5,4)
print(z)
```
gives it the dim attribute that allows it to be treated as a 3 by 5 by 4 array.

The values in the data vector give the values in the array in *column major order*, with the first subscript moving fastest and the last subscript slowest.

For example if the dimension vector for an array, say a, is c(3,4,2) then there are 3 * 4 * 2 = 24 entries in a and the data vector holds them in the order 

a[1,1,1], a[2,1,1], …, a[2,4,2], a[3,4,2].

Arrays can be one-dimensional: such arrays are usually treated in the same way as vectors (including when printing), but the exceptions can cause confusion.

Individual elements of an array may be referenced by giving the name of the array followed by the subscripts in square brackets, separated by commas.

More generally, subsections of an array may be specified by giving a sequence of index vectors in place of subscripts; however if any index position is given an empty index vector, then the full range of that subscript is taken.

Continuing the previous example, a[2,,] is a 4 * 2 array with dimension vector c(4,2) and data vector containing the values

c(a[2,1,1], a[2,2,1], a[2,3,1], a[2,4,1], a[2,1,2], a[2,2,2], a[2,3,2], a[2,4,2])

in that order. 

a[,,] stands for the entire array, which is the same as omitting the subscripts entirely and using a alone.

For any array, say Z, the dimension vector may be referenced explicitly as *dim(Z)* (on either side of an assignment).

Also, if an array name is given with just one subscript or index vector, then the corresponding values of the data vector only are used; in this case the dimension vector is ignored. This is not the case, however, if the single index is not a vector but itself an array.

As well as an index vector in any subscript position, a matrix may be used with a single index matrix in order either to assign a vector of quantities to an irregular collection of elements in the array, or to extract an irregular collection as a vector.

A matrix example makes the process clear. In the case of a doubly indexed array, an index matrix may be given consisting of two columns and as many rows as desired. The entries in the index matrix are the row and column indices for the doubly indexed array. Suppose for example we have a 4 by 5 array X and we wish to do the following:

* Extract elements X[1,3], X[2,2] and X[3,1] as a vector structure, and
* Replace these entries in the array X by zeroes.

In this case we need a 3 by 2 subscript array, as in the following example.
```{r}
x <- array(1:20, dim=c(4,5))   # Generate a 4 by 5 array.
print(x)
```
```{r}
i <- array(c(1:3,3:1), dim=c(3,2))
print(i) # i is a 3 by 2 index array.
```
```{r}
print(x[i])   # Extract those elements
```
```{r}
x[i] <- 0                     # Replace those elements by zeros.
print(x)
```
Negative indices are not allowed in index matrices. NA and zero values are allowed: rows in the index matrix containing a zero are ignored, and rows containing an NA produce an NA in the result.

As a less trivial example, suppose we wish to generate an (unreduced) design matrix for a block design defined by factors blocks (b levels) and varieties (v levels). Further suppose there are n plots in the experiment. We could proceed as follows:
```{r, eval=FALSE}
Xb <- matrix(0, n, b)
Xv <- matrix(0, n, v)
ib <- cbind(1:n, blocks)
iv <- cbind(1:n, varieties)
Xb[ib] <- 1
Xv[iv] <- 1
X <- cbind(Xb, Xv)
```
To construct the incidence matrix, N say, we could use
```{r, eval=FALSE}
N <- crossprod(Xb, Xv)
```
However a simpler direct way of producing this matrix is to use table():
```{r, eval=FALSE}
N <- table(blocks, varieties)
```
Index matrices must be numerical: any other form of matrix (*e.g.*, a logical or character matrix) supplied as a matrix is treated as an indexing vector.

As well as giving a vector structure a dim attribute, arrays can be constructed from vectors by the array function, which has the form
```{r,eval=FALSE}
Z <- array(data_vector, dim_vector)
```
For example, if the vector h contains 24 or fewer numbers, then the command
```{r, eval=FALSE}
Z <- array(h, dim=c(3,4,2))
```
would use h to set up 3 by 4 by 2 array in Z. If the size of h is exactly 24 the result is the same as
```{r, eval=FALSE}
Z <- h 
dim(Z) <- c(3,4,2)
```
However if h is shorter than 24, its values are recycled from the beginning again to make it up to size 24, but dim(h) <- c(3,4,2) would signal an error about mismatching length. 
As an extreme but common example, *Z <- array(0, c(3,4,2))* makes Z an array of all zeros.

At this point *dim(Z)* stands for the dimension vector *c(3,4,2)*, and *Z[1:24]* stands for the data vector as it was in h, and *Z[]* with an empty subscript or *Z* with no subscript stands for the entire array as an array.

Arrays may be used in arithmetic expressions and the result is an array formed by element-by-element operations on the data vector. The dim attributes of operands generally need to be the same, and this becomes the dimension vector of the result. So if A, B and C are all similar arrays, then *D <- 2*A*B + C + 1*
makes D a similar array with its data vector being the result of the given element-by-element operations. However the precise rule concerning mixed array and vector calculations has to be considered a little more carefully.

The function *aperm(a, perm)* may be used to permute an array, a. The argument perm must be a permutation of the integers {1, …, k}, where k is the number of subscripts in a. The result of the function is an array of the same size as a but with old dimension given by perm[j] becoming the new j-th dimension. 
The easiest way to think of this operation is as a generalization of transposition for matrices. Indeed if A is a matrix, (that is, a doubly subscripted array) then B given by
```{r, eval=FALSE}
B <- aperm(A, c(2,1))
```
is just the transpose of A. For this special case a simpler function *t()* is available, so we could have used 
```{r, eval=FALSE}
B <- t(A)
```
The operator %*% is used for matrix multiplication. An n by 1 or 1 by n matrix may of course be used as an n-vector if in the context such is appropriate. Conversely, vectors which occur in matrix multiplication expressions are automatically promoted either to row or column vectors, whichever is multiplicatively coherent, if possible, (although this is not always unambiguously possible, as we see later).

If, for example, A and B are square matrices of the same size, then
```{r, eval=FALSE}
A * B
```
is the matrix of element by element products and
```{r, eval=FALSE}
A %*% B
```
is the matrix product.

The meaning of *diag()* depends on its argument:

* *diag(v)*, where v is a vector, gives a diagonal matrix with elements of the vector as the diagonal entries
* *diag(M)*, where M is a matrix, gives the vector of main diagonal entries of M
* if k is a single numeric value then *diag(k)* is the k by k identity matrix

Matrices can also be built up from other vectors and matrices by the functions *cbind()* and *rbind()*. Roughly *cbind()* forms matrices by binding together matrices horizontally, or column-wise, and *rbind()* vertically, or row-wise.

In the assignment
```{r, eval=FALSE}
X <- cbind(arg_1, arg_2, arg_3, …)
```
the arguments to *cbind()* must be either vectors of any length, or matrices with the same column size, that is the same number of rows. The result is a matrix with the concatenated arguments arg_1, arg_2, … forming the columns.

If some of the arguments to *cbind()* are vectors they may be shorter than the column size of any matrices present, in which case they are cyclically extended to match the matrix column size (or the length of the longest vector if no matrices are given).

The function *rbind()* does the corresponding operation for rows. In this case any vector argument, possibly cyclically extended, are of course taken as row vectors.

Suppose X1 and X2 have the same number of rows. To combine these by columns into a matrix X, together with an initial column of 1s we can use
```{r, eval=FALSE}
X <- cbind(1, X1, X2)
```

```{r}
aa<-c(1,2,3)
bb<-c(4,5,6)
print(cbind(aa,bb))
print(rbind(aa,bb))
```

The result of *rbind()* or *cbind()* always has matrix status. Hence *cbind(x)* and *rbind(x)* are possibly the simplest ways explicitly to allow the vector x to be treated as a column or row matrix respectively.

Whereas *cbind()* and *rbind()* are concatenation functions that respect dim attributes, the basic *c()* function does not, but rather clears numeric objects of all dim (and dimnames) attributes. This is occasionally useful in its own right.

The official way to coerce an array back to a simple vector object is to use *as.vector()*
```{r, eval=FALSE}
vec <- as.vector(X)
```
However a similar result can be achieved by using *c()* with just one argument, simply for this side-effect:
```{r, eval=FALSE}
vec <- c(X)
```
There are slight differences between the two, but ultimately the choice between them is largely a matter of style (with the former being preferable).

***
## Lists
An R list is an object consisting of an ordered collection of objects known as its components.

There is no particular need for the components to be of the same mode or type, and, for example, a list could consist of a numeric vector, a logical value, a matrix, a complex vector, a character array, a function, and so on. Here is a simple example of how to make a list:

```{r}
Lst <- list(name="Fred", wife="Mary", no.children=3, child.ages=c(4,7,9))
print(Lst)
```
Components are always numbered and may always be referred to as such. Thus if Lst is the name of a list with four components, these may be individually referred to as *Lst[[1]], Lst[[2]], Lst[[3]]* and *Lst[[4]]*. If, further, *Lst[[4]]* is a vector subscripted array then *Lst[[4]][1]* is its first entry.

If Lst is a list, then the function *length(Lst)* gives the number of (top level) components it has.

```{r}
print(length(Lst))
```
Components of lists may also be named, and in this case the component may be referred to either by giving the component name as a character string in place of the number in double square brackets, or, more conveniently, by giving an expression of the form *name$component_name* for the same thing.

This is a very useful convention as it makes it easier to get the right component if you forget the number.

So in the simple example given above:

```{r}
print(Lst$name)
print(Lst[[1]])

print(Lst$wife) 
print(Lst[[2]])

print(Lst$child.ages[1]) 
print(Lst[[4]][1]) 
```
Additionally, one can also use the names of the list components in double square brackets, *i.e., Lst[["name"]]* is the same as *Lst$name*. This is especially useful, when the name of the component to be extracted is stored in another variable as in
```{r}
x <- "name"
print(Lst[[x]])
```

It is very important to distinguish *Lst[[1]]* from *Lst[1]*. 

* *[[…]]* is the operator used to select a single element, thus *Lst[[1]]* is the first object in the list Lst, and if it is a named list the name is not included;
* *[…]* is a *general* subscripting operator, so *Lst[1]* is a sublist of the list Lst consisting of the first entry only and if it is a named list, the names are transferred to the sublist.

The names of components may be abbreviated down to the minimum number of letters needed to identify them uniquely. Thus *Lst\$coefficients* may be minimally specified as *Lst\$coe* and *Lst\$covariance* as *Lst\$cov*: the vector of names is in fact simply an attribute of the list like any other and may be handled as such. Other structures besides lists may, of course, similarly be given a names attribute also.

New lists may be formed from existing objects by the function *list()*. An assignment of the form

```{r, eval=FALSE}
Lst <- list(name_1=object_1, …, name_m=object_m)
```

sets up a list Lst of m components using object_1, …, object_m for the components and giving them names as specified by the argument names, (which can be freely chosen). If these names are omitted, the components are numbered only. The components used to form the list are copied when forming the new list and the originals are not affected.

Lists, like any subscripted object, can be extended by specifying additional components. For example

```{r, eval=FALSE}
Lst[5] <- list(matrix=Mat)
```

When the concatenation function *c()* is given list arguments, the result is an object of mode list also, whose components are those of the argument lists joined together in sequence.
```{r, eval=FALSE}
list.ABC <- c(list.A, list.B, list.C)
```
Recall that with vector objects as arguments the concatenation function similarly joined together all arguments into a single vector structure. In this case all other attributes, such as dim attributes, are discarded.

***
## Data frames
A data frame is a list with class "data.frame". There are restrictions on lists that may be made into data frames, namely:

* the components must be vectors (numeric, character, or logical), factors, numeric matrices, lists, or other data frame;
* matrices, lists, and data frames provide as many variables to the new data frame as they have columns, elements, or variables, respectively;
* numeric vectors, logicals and factors are included as is, and by default character vectors are coerced to be factors, whose levels are the unique values appearing in the vector;
* vector structures appearing as variables of the data frame must all have the same length, and matrix structures must all have the same row size.

A data frame may for many purposes be regarded as a matrix with columns possibly of differing modes and attributes. It may be displayed in matrix form, and its rows and columns extracted using matrix indexing conventions.

Objects satisfying the restrictions placed on the columns (components) of a data frame may be used to form one using the function data.frame:
```{r}
print(statef)
print(incomes)
print(incomef)
```

```{r}
accountants <- data.frame(home=statef, loot=incomes, shot=incomef)
print(accountants)
```

A list whose components conform to the restrictions of a data frame may be coerced into a data frame using the function *as.data.frame()*

The simplest way to construct a data frame from scratch is to read an entire data frame (table) from an external file.

The \$ notation, such as *accountants$home*, for list components is not always very convenient. A useful facility would be somehow to make the components of a list or data frame temporarily visible as variables under their component name, without the need to quote the list name explicitly each time.

The *attach()* function takes a ‘database’ such as a list or data frame as its argument. Thus suppose *lentils* is a data frame with three variables *lentils\$u, lentils\$v, lentils\$w*. The command
```{r, eval=FALSE}
attach(lentils)
```
places the data frame in the search path at position 2, and provided there are no variables *u, v* or *w* in position 1, *u, v* and *w* are available as variables from the data frame in their own right. At this point an assignment such as *u <- v+w* does not replace the component *u* of the data frame, but rather masks it with another variable *u* in the working directory at position 1 on the search path. To make a permanent change to the data frame itself, the simplest way is to resort once again to the $ notation:
```{r, eval=FALSE}
lentils$u <- v+w
```
However the new value of component *u* is not visible until the data frame is detached and attached again.

To detach a data frame, use the function *detach()* .
More precisely, this statement detaches from the search path the entity currently at position 2. Thus in the present context the variables *u, v* and *w* would be no longer visible, except under the list notation as *lentils$u* and so on. Entities at positions greater than 2 on the search path can be detached by giving their number to detach, but it is much safer to always use a name, for example by *detach(lentils)* or *detach("lentils")*.

In R lists and data frames can only be attached at position 2 or above, and what is attached is a copy of the original object. You can alter the attached values via assign, but the original list or data frame is unchanged.

*attach()* is a generic function that allows not only directories and data frames to be attached to the search path, but other classes of object as well. In particular any object of mode "list" may be attached in the same way by *attach(any.old.list)*. Anything that has been attached can be detached by detach, by position number or, preferably, by name.

***
# Read data from files
Large data objects will usually be read as values from external files rather than entered during an R session at the keyboard. R input facilities are simple and their requirements are fairly strict and even rather inflexible. There is a clear presumption by the designers of R that you will be able to modify your input files using other tools, such as file editors or Perl20 to fit in with the requirements of R. Generally this is very simple.

If variables are to be held mainly in data frames, as we strongly suggest they should be, an entire data frame can be read directly with the read.table() function. There is also a more primitive input function, scan(), that can be called directly.

To read an entire data frame directly, the external file will normally have a special form.

* The first line of the file should have a name for each variable in the data frame.
* Each additional line of the file has as its first item a row label and the values for each variable.

If the file has one fewer item in its first line than in its second, this arrangement is presumed to be in force. So the first few lines of a file to be read as a data frame might look as follows.

If the file has one fewer item in its first line than in its second, this arrangement is presumed to be in force. So the first few lines of a file to be read as a data frame might look as follows.

\ |Price|Floor|Area|Rooms|Age|Cent.heat
--|-----|-----|----|-----|---|---------
01|52.00|111.0| 830|    5|6.2|      no
02|54.75|128.0| 710|    5|7.5|      no
03|57.50|101.0|1000|    5|4.2|      no
04|57.50|131.0| 690|    6|8.8|      no
05|59.75| 93.0| 900|    5|1.9|     yes
..|

By default numeric items (except row labels) are read as numeric variables and non-numeric variables, such as Cent.heat in the example, as factors. This can be changed if necessary.

The function *read.table()* can then be used to read the data frame directly
```{r, eval=FALSE}
HousePrice <- read.table("houses.data")
```

Often you will want to omit including the row labels directly and use the default labels. In this case the file may omit the row label column as in the following.

Price|Floor|Area|Rooms|Age|Cent.heat
-----|-----|----|-----|---|---------
52.00|111.0| 830|    5|6.2|      no
54.75|128.0| 710|    5|7.5|      no
57.50|101.0|1000|    5|4.2|      no
57.50|131.0| 690|    6|8.8|      no
59.75| 93.0| 900|    5|1.9|     yes 
 ... |

The data frame may then be read as
```{r, eval=FALSE}
HousePrice <- read.table("houses.data", header=TRUE)
```
where the *header=TRUE* option specifies that the first line is a line of headings, and hence, by implication from the form of the file, that no explicit row labels are given.

In alternative, a newer function for reading files is *read_delim()* and similar, from the *readr* package.

Around 100 datasets are supplied with R (in package datasets), and others are available in packages (including the recommended packages supplied with R). To see the list of datasets currently available use
```{r}
data()
```
All the datasets supplied with R are available directly by name. However, many packages still use the obsolete convention in which data was also used to load datasets into R, for example
```{r}
data(infert)
```
and this can still be used with the standard packages (as in this example). In most cases this will load an R object of the same name. However, in a few cases it loads several objects, so see the on-line help for the object to see what to expect.

To access data from a particular package, use the package argument, for example
```{r}
data(package="rpart")
data(Puromycin, package="datasets")
```
If a package has been attached by library, its datasets are automatically included in the search.

The function *str()* can be used to overview the structure of an object
```{r}
str(Puromycin)
head(Puromycin)
```

***
# Control statements
The language has available a conditional construction of the form
```{r, eval=FALSE}
if (expr_1) expr_2 else expr_3
```
where expr_1 must evaluate to a single logical value and the result of the entire expression is then evident.

The “short-circuit” operators && and || are often used as part of the condition in an if statement. Whereas & and | apply element-wise to vectors, && and || apply to vectors of length one, and only evaluate their second argument if necessary.

There is a vectorized version of the if/else construct, the *ifelse* function. This has the form *ifelse(condition, a, b)* and returns a vector of the same length as condition, with elements *a[i]* if condition[i] is true, otherwise *b[i]*  (where a and b are recycled as necessary).

There is also a for loop construction which has the form
```{r, eval=FALSE}
for (name in expr_1) expr_2
```
where name is the loop variable. expr_1 is a vector expression, (often a sequence like 1:20), and expr_2 is often a grouped expression with its sub-expressions written in terms of the dummy name. expr_2 is repeatedly evaluated as name ranges through the values in the vector result of expr_1.

*For()* loops are used in R code much less often than in compiled languages. Code that takes a *whole object* view is likely to be both clearer and faster in R.

Other looping facilities include the *repeat expr* statement and the *while (condition) expr* statements.
The *break* statement can be used to terminate any loop, possibly abnormally. This is the only way to terminate repeat loops. The *next* statement can be used to discontinue one particular cycle and skip to the “next”. 

## Functions
The R language allows the user to create objects of mode function. These are true R functions that are stored in a special internal form and may be used in further expressions and so on. 

It should be emphasized that most of the functions supplied as part of the R system, such as *mean()*, *var()*, *postscript()* and so on, are themselves written in R and thus do not differ materially from user written functions.

A function is defined by an assignment of the form
```{r, eval=FALSE}
name <- function(arg_1, arg_2, …) expression
```
The expression is an R expression that uses the arguments, arg_i, to calculate a value. The value of the expression is the value returned for the function.

A call to the function then usually takes the form *name(expr_1, expr_2, …)* and may occur anywhere a function call is legitimate.

As an example, we define the function returning the area of a triangle given its cartesian coordinates *(x_a,y_a), (x_b,y_b), (x_c,y_c)*:
```{r}
area_tr <- function(x_a,y_a,x_b,y_b,x_c,y_c){
  M <- matrix(c(x_a,x_b,x_c,y_a,y_b,y_c,1,1,1),3,3,byrow = TRUE)
  A <- 1/2*det(M)
  return(A)
}
```
and we apply it to the triangle with coordinates (1,3), (1,1) and (3,1):
```{r}
print(area_tr(1,3,1,1,3,1))
```

If arguments to called functions are given in the “name=object” form, they may be given in any order. Furthermore the argument sequence may begin in the unnamed, positional form, and specify named arguments after the positional arguments.

Thus if there is a function *fun1* defined by
```{r, eval=FALSE}
fun1 <- function(data, data.frame, graph, limit) {
    [function body omitted]
}
```
then the function may be invoked in several ways, for example
```{r, eval=FALSE}
ans <- fun1(d, df, TRUE, 20)
ans <- fun1(d, df, graph=TRUE, limit=20)
ans <- fun1(data=d, limit=20, graph=TRUE, data.frame=df)
```
are all equivalent.

In many cases arguments can be given commonly appropriate default values, in which case they may be omitted altogether from the call when the defaults are appropriate. For example, if fun1 were defined as
```{r, eval=FALSE}
fun1 <- function(data, data.frame, graph=TRUE, limit=20) { … }
```
it could be called as
```{r, eval=FALSE}
ans <- fun1(d, df)
```
which is now equivalent to the three cases above, or as
```{r, eval=FALSE}
ans <- fun1(d, df, limit=10)
```
which changes one of the defaults.

It is important to note that defaults may be arbitrary expressions, even involving other arguments to the same function; they are not restricted to be constants as in our simple example here.
Another frequent requirement is to allow one function to pass on argument settings to another. For example many graphics functions use the function *par()* and functions like *plot()* allow the user to pass on graphical parameters to *par()* to control the graphical output. This can be done by including an extra argument, literally ‘…’, of the function, which may then be passed on. An outline example is given below.
```{r, eval=FALSE}
fun1 <- function(data, data.frame, graph=TRUE, limit=20, ...) {
  [omitted statements]
  if (graph)
    par(pch="*", ...)
  [more omissions]
}
```
Less frequently, a function will need to refer to components of ‘…’. The expression *list(...)* evaluates all such arguments and returns them in a named list, while ..1, ..2, etc. evaluate them one at a time, with ‘..n’ returning the n’th unmatched argument.

***
# The *apply()* family of functions
The *apply()* family pertains to the R base package and is populated with functions to manipulate slices of data from matrices, arrays, lists and dataframes in a repetitive way. These functions allow crossing the data in a number of ways and avoid explicit use of loop constructs. They act on an input list, matrix or array and apply a named function with one or several optional arguments.

The called function could be:

* An aggregating function, like for example the mean, or the sum (that return a number or scalar);
* Other transforming or subsetting functions; and
* Other vectorized functions, which yield more complex structures like lists, vectors, matrices, and arrays.

The *apply()* functions form the basis of more complex combinations and helps to perform operations with very few lines of code. More specifically, the family is made up of the *apply(), lapply() , sapply(), vapply(), mapply(), rapply()*, and *tapply()* functions.

The base element of the family, *apply()*, operates on arrays as *apply(X, MARGIN, FUN, ...)* where:

* X is an array or a matrix if the dimension of the array is 2;
* MARGIN is a variable defining how the function is applied: when MARGIN=1, it applies over rows, whereas with MARGIN=2, it works over columns. Note that when you use the construct MARGIN=c(1,2), it applies to both rows and columns; and
* FUN, which is the function that you want to apply to the data. It can be any R function, including a user defined function.

Let’s construct a 5 x 6 random matrix and compute sum the values of each column (the function *runif(n=N,min=m,max=M)* generates a vector of N random decimal number in the interval $[m,M]$):
```{r}
M <- matrix(runif(n=5*6,min=0,max=1),5,6)
print(M)
apply(M,2,sum)
```


The *lapply()* function applies to every element of a list and returns a list as a result. However, 

* it can be used for other objects like dataframes, lists or vectors; and
* the output returned is a list (which explains the “l” in the function name), which has the same number of elements as the object passed to it.
```{r}
AA <- matrix(floor(runif(5*5,1,10)),5,5)
BB <- matrix(runif(3*6),3,6)
CC <- matrix(-runif(4*4),4,4)

MyList <- list(AA,BB,CC)
print(MyList)
lapply(MyList,"[",1,)
lapply(MyList,"[",,2)
```
The *sapply()* function works like *lapply()*, but it tries to simplify the output to the most elementary data structure that is possible: internally, *sapply()* is a wrapper function for *lapply()*. Calling *lapply()* with *unlist()* and *sapply()* with parameter *simplify=FALSE* covers all possible alternatives, but it is best to use these functions in their ‘native format’ and avoid conversions unless strictly necessary.
```{r}
print(lapply(MyList, "[",1,2))

print(sapply(MyList,"[",1,2, simplify=FALSE))

print(unlist(lapply(MyList, "[",1,2)))

print(sapply(MyList,"[",1,2))
```
Something that is often used together with *apply()* functions is *rep()*. When you apply it to a vector or a factor x, the function replicates its values a specified number of times.

Let’s use one of the vectors that you generated above with *lapply()* into MyList.

This time, however, you only select the elements of the first line and first column from each elements of the list MyList (and you use *sapply()* to get a vector):
```{r}
# Initialize `Z`
Z <- sapply(MyList,"[", 1,1 )

# Return `Z`
Z

# Replicate the values of `Z`
Z <- rep(Z,c(3,1,2))

# Return `Z`
Z
```
The *mapply()* function stands for ‘multivariate’ apply. Its purpose is to be able to vectorize arguments to a function that is not usually accepting vectors as arguments.

In short, *mapply()* applies a Function to Multiple List or multiple Vector Arguments.

Let’s look at a *mapply()* example where you create a 4 x 4 matrix with a call to the *rep()* function repeatedly:
```{r}
# Create a 4x4 matrix
Q1 <- matrix(c(rep(1, 4), rep(2, 4), rep(3, 4), rep(4, 4)),4,4)

# Print `Q1`
print(Q1)

# Or use `mapply()`
Q2 <- mapply(rep,1:4,4)

# Print `Q2`
print(Q2)
```
This is a more efficient way to bind the results of the *rep()* function instead of with *c()*: the call *mapply()* vectorizes the action of the function *rep()*.





